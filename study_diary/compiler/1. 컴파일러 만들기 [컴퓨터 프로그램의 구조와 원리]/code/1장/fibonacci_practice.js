// for문 **************************************************************************
// 시간 복잡도 => O(n)
// 공간 복잡도 => O(1)
// 빅오 => 상한
// 빅오메가 => 하한
// 빅오라는 것이 worst case(최악의 경우) 동일한 의미는 아님
function fibonacciFor(n) {
  let a = 0;
  let b = 1;
  let prevA;
  for (let i = 0; i < n; i += 1) {
    prevA = a;
  }
}

// 재귀 1 ****************************************************************************
// 시간 복잡도(연산횟수) => O(2^n)
// 공간 복잡도(메모리에 얼마나 잡히냐) => O(n)
// * 변수 선언한 부분이 없어서, O(1)이라고
function fibonacciRecursive01(n) {
  // recursive tail(재귀 꼬리)
  if (n === 0) return 0;
  if (n === 1) return 1;

  return fibonacciRecursive01(n - 2) + fibonacciRecursive01(n - 1);
}
// console.log(fibonacciRecursive01(10));

// 재귀 2 ****************************************************************************
// 캐쉬를 이용해서 작성해보기

function fibonacciRecursive02(n) {
  const cache = Array(100).fill(null);
  return;
}

// **********************************************************************************
// 재귀(Recursion)
// 정의 : 함수가 자기 자신을 호출하는 것
// 수학적 귀납법, 점화식...

// 재귀 -> 재귀 호출 스택
// 재귀 호출 : 함수가 자기 자신을 호출할때, 스택에 push & pop이 일어난다.

// 시간 복잡도 : 컴퓨터 연산할때 성능을 측정하는 것. 시간적인 성능을 측정
// 시간 복잡도 : O(n)
// 시간 복잡도, 공간 복잡도, ...
const arr1 = [1, 2, 3, 4, 5];
for (let i = 0; i < arr1.length; i += 1) {
  // console.log(arr1[i]);
}
// 꼬리 재귀 ?
// *********************************************************************************
