## 4.1 변수란 무엇인가? 왜 필요한가?

- 변수란 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념

- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억

> 메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체, 메모리 셀의 크기는 1바이트(8bit)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽는다.

- 메모리의 각 셀은 고유의 주소(메모리 공간의 위치)를 가짐

```javascript
// 10과 20은 메모리 상의 임의의 메모리 주소에 기억되고 CPU는 이 값을 읽어 연산
// 연산 결과로 생성된 숫자값 30도 메모리 상의 임의의 위치에 저장 (==> 편의상 10진수, 사실은 2진수로 저장)
10 + 20;
```

- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. ( 치명적인 오류 발생 사전 차단 )

- 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공

- _변수_ : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 ( 값의 위치를 가리키는 상징적인 이름 )

```javascript
// 위의 10 + 20과 달리 result라는 변수에 연산된 값을 대입했기 때문에,
// 개발자는 해당 연산된 값이 저장된 메모리 주소를 알 필요 없이 'result'라는 이름으로 연산된 값을 사용할 수 있다.

// result -> 변수 이름, 30 -> 변수 값
let result = 10 + 20;
```

## 4.2 식별자 (identifier)

- 변수 이름을 식별자라고도 함

- 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름, 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 또한 메모리에 저장 ( ==> 식별자는 값이 아니라, 메모리 주소를 기억하고 있다. )

- 변수, 함수, 클래스 등의 이름처럼 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 식별자라고 함

## 4.3 변수 선언

- 변수 선언 : 변수를 생성하는 것, `var` & `let` & `const`

> 1. 값을 저장하기 위한 메모리 공간 확보 ( allocate )
>
> 2. 변수 이름과 확보된 메모리 공간의 주소를 연결 ( name binding )해서 값을 저장할 수 있게 준비

> 키워드 : 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어, 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행

```javascript
var score; // undefined ( 선언만 했지만, JS 엔진에 의해 undefined가 암묵적으로 할당되어 초기화 )
```

1. 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수에 존재를 알림

2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화

> 변수 이름은 어디에 등록되는가?
>
> 변수 이름을 비롯한 모든 식별자는 `실행 컨텍스트`에 등록된다. 실행 컨텍스트는 JS 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined

var score; // 변수 선언문

// 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 하지만 참조 에러(ReferenceError)가 발생하지 않고 'undefined'가
// 출력되는 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 runtime이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.
// 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행할 준비를 한다.
// 이때 실행 전 평가 과정에서 JS 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
// 모든 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행
// 즉, JS 엔진은 변수 선언이 소스코드의 어디에 있든 상관 없이 다른 코드보다 먼저 실행한다!!!
```

- 위의 내용 처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징을 _변수 호이스팅_(variable hoisting)이라 한다.

## 4.5 값의 할당

- `=` 할당 연산자 사용

```javascript
let score = 80;

// 위와 같이 선언과 할당을 한 문장으로 작성해도, 아래 처럼 동작한다. ( 선언과 할당의 실행 시점이 다르다 )
let score; // => 소스코드가 실행되는 시점인 런타임 이전에 먼저 실행
score = 80; // => 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행
```

```javascript
console.log(score); // undefined ( 평가 과정에서 변수 호이스팅에 의해 score가 선언만 되었기 때문에 undefined )

let score = 80; // 런타임 시점에 위의 console.log()가 수행되고 80이 score에 할당

console.log(score); // 80
```

## 4.6 값의 재할당

- 재할당 : 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

```javascript
let score = 80;
score = 90;

// 90이란 값이 score에 재할당 되면, 새로운 메모리 주소에 값이 저장되는데 이때 80이 저장된 메모리 주소는 아무도 사용하고 있지 않기 때문에 더이상 필요로 하지 않다.
// 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.
```

> 가비지 콜렉터 : 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
>
> 더 이상 사용되지 않는 메모리 : 어떤 식별자도 참조하지 않는 메모리 공간을 의미
>
> 자바스크립트는 매니지드 언어로서 메모리의 할당과 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다.

- 만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라고 함

## 4.7 식별자 네이밍 규칙
